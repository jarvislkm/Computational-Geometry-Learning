#include <iostream>
#include <fstream>
#include <vector>
#include <algorithm>
#include "coast_line.h"
#include "coast_node.h"
#include "point.h"
#include "site.h"
#include "Eventqueue.h"

using namespace std;

const double vx_max = 1000;
const double vx_min = 0;
const double vy_max = 1000;
const double vy_min = 0;

bool add_circle_event(coast_node* work, eventqueue& circle_event_queue, double position) {
	cir_res r1 = circle_detect(work); 
	if (r1.success && r1.circle_point.y <= position) {
		Event_circle* s1 = new Event_circle(r1.circle_point.x, r1.circle_point.y);
		s1->node = work;
		s1->center = r1.circle_center;
		s1->circle[0] = work->pred->leaf.id;
		s1->circle[1] = work->leaf.id;
		s1->circle[2] = work->suc->leaf.id;
		circle_event_queue.insert(s1);
		work->re_event = s1;
		return true;
	};
	return false;
}

bool in_box(double x, double y) {
	return vx_min < x && x < vx_max && vy_min < y && y < vy_max;
}

void traverse(coast_node* work, double po, vector<vertex* >& vertex_vec) {
	if (work->is_leaf()) return;
	traverse(work->lc, po, vertex_vec);
	double x, y, x0, y0, dx, dy;
	do
	{
		x = work->break_point(po);
		x0 = work->p1.p.x;
		y0 = work->p1.p.y;
		y = ((x - x0)*(x - x0) + y0*y0 - po*po) / (2 * (y0-po));
		dx = x - x0;
		dy = y - y0;
		po -= 100;
	} while (in_box(x, y));

	vertex* v = new vertex(vertex_vec.size(), x, y);
	work->edge->ori = v;
	v->inc_edge = work->edge;
	vertex_vec.push_back(v);
	traverse(work->rc, po, vertex_vec);
}

void read(int & number, vector<site>& site_point) {
	ifstream in;
	in.open("data.txt");
	in >> number;
	int s = 0;
	int a, b;
	while (s < number) {
		in >> a >> b;
		site to_add(a, b, s++);
		site_point.push_back(to_add);
	}
}

int main() {
	int number = 0;
	vector<half_edge*> edge_vec;
	vector<vertex* > vertex_vec;
	vector<site> site_point;
	read(number, site_point);
	sort(site_point.begin(), site_point.end(), sort_site);

	coast_node* start_node = new coast_node(site_point[0]);
	coast_line cl(start_node);
	int site_event_now = 1;
	eventqueue circle_event_queue;

	while (site_event_now != number || circle_event_queue.getMax()) {
		bool site_event_sign;
		if (!circle_event_queue.getMax()) { site_event_sign = true; }
		else if (site_event_now == number) { site_event_sign = false; }
		else if (site_point[site_event_now].p < circle_event_queue.getMax()->eventpoint) { site_event_sign = false; }
		else site_event_sign = true;

		if (site_event_sign) {// site event
			cl.position = site_point[site_event_now].p.y;
			coast_node* to_replace = cl.insert(site_point[site_event_now], edge_vec);
			circle_event_queue.delete_element(to_replace->re_event); // delete original event;
			add_circle_event(to_replace->parent->pred, circle_event_queue, cl.position+1); // parent of replace is new inserted arc!
			add_circle_event(to_replace->parent->suc, circle_event_queue, cl.position+1); // circle event generated by site event should not be limited by coast line position
			delete to_replace;
			site_event_now++;
		}
		else {//circle event
			Event_circle* to_delete = circle_event_queue.delMax();
			cl.position = to_delete->eventpoint.y;
			coast_node* to_move = to_delete->node;
			coast_node* work = to_move->parent;
			double should_remove = work->break_point(to_delete->eventpoint.y) - to_delete->eventpoint.x;

			if (-1e-8<should_remove && should_remove < 1e-8) {
				vertex* vt = new vertex(vertex_vec.size(), to_delete->center.x, to_delete->center.y);
				vt->r = to_delete->center.y - to_delete->eventpoint.y;
				vertex_vec.push_back(vt);

				coast_node* to_remove = cl.remove(to_delete, vt, edge_vec);
				circle_event_queue.delete_element(to_remove->pred->re_event);
				circle_event_queue.delete_element(to_remove->suc->re_event);

				add_circle_event(to_remove->pred, circle_event_queue, cl.position - 1e-10);
				add_circle_event(to_remove->suc, circle_event_queue, cl.position - 1e-10);
			}
			else {
				to_move->re_event = NULL;
			}
			delete to_delete;
		}
	}

	//double vx_max = 1000;
	//double vx_min = 0;
	//double vy_max = 1000;
	//double vy_min = 0;

	//for (auto u : vertex_vec) {
	//	if (vx_max < u->x) vx_max = u->x;
	//	if (vx_min > u->x) vx_min = u->x;
	//	if (vy_max < u->y) vy_max = u->y;
	//	if (vy_min > u->y) vy_min = u->y;
	//}
	//vx_max += 5;
	//vx_min -= 5;
	//vy_max += 5;
	//vy_min -= 5;

	cl.position -= 4000;
	coast_node* work = cl.root;

	vector<vertex* > out_vertex;
	vector<half_edge*> out_edge;
	traverse(work, cl.position, out_vertex);

	for (int i = 0; i < out_vertex.size() ; i++) {
		int succ_vertex;
		if (i == out_vertex.size() - 1) {succ_vertex = 0;}
		else succ_vertex = i + 1;
		half_edge* out_e = new half_edge(out_edge.size());
		out_e->ori = out_vertex.at(succ_vertex);
		out_vertex.at(i)->inc_edge->succ = out_e;
		out_e->pre = out_vertex.at(i)->inc_edge;

		out_vertex.at(succ_vertex)->inc_edge->twin->pre = out_e;
		out_e->succ = out_vertex.at(succ_vertex)->inc_edge->twin;

		out_edge.push_back(out_e);
	}

	ofstream out;
	out.open("result.txt");
	for (auto s : edge_vec) {
		if (s->ori && s->twin->ori) {
			out << s->ori->x << " " << s->ori->y << endl;
		}
	}
//	out << "This is test" << endl;
	for (int i = 0; i < out_edge.size();i++) {
		auto s = out_edge.at(i);
		int a=i+1;
		if (i == out_edge.size() - 1) { a = 0; }
		auto s_b = out_edge.at(a);
		out << s->ori->x << " " << s->ori->y << endl;
		out << s_b->ori->x << " " << s_b->ori->y << endl;
	}
	return 0;
}
